/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";

// src/workers/imageWorker.ts
var DB_NAME = "lumina-image-cache";
var DB_VERSION = 1;
var STORE_NAME = "images";
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onerror = () => reject(req.error);
    req.onsuccess = () => resolve(req.result);
    req.onupgradeneeded = () => {
      req.result.createObjectStore(STORE_NAME, { keyPath: "path" });
    };
  });
}
function getCachedBlob(path) {
  return openDB().then((db) => {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readonly");
      const req = tx.objectStore(STORE_NAME).get(path);
      req.onsuccess = () => {
        var _a;
        const row = req.result;
        resolve((_a = row == null ? void 0 : row.blob) != null ? _a : null);
      };
      req.onerror = () => reject(req.error);
    }).finally(() => db.close());
  });
}
function setCachedBlob(path, blob) {
  return openDB().then((db) => {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, "readwrite");
      const req = tx.objectStore(STORE_NAME).put({ path, blob });
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    }).finally(() => db.close());
  });
}
self.onmessage = (e) => {
  const { id, url, path } = e.data;
  getCachedBlob(path).then((blob) => {
    if (blob) return createImageBitmap(blob);
    return fetch(url).then((r) => r.ok ? r.blob() : Promise.reject(new Error("fetch failed"))).then((b) => {
      setCachedBlob(path, b).catch(() => {
      });
      return createImageBitmap(b);
    });
  }).then((bitmap) => {
    self.postMessage({ id, bitmap }, [bitmap]);
  }).catch(() => {
    self.postMessage({ id, error: true });
  });
};
